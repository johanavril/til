# Escape Analysis in Go

As we know, our program store the variable into 2 storage, stack and heap. Memory allocation on the stack generally cheaper than heap. Most of the time, Go will allocate our variable into the stack frame of a function if possible, but there are some special cases where the Go's compiler cannot prove that the variable is not referenced outside the function / stack, then it will goes to the heap. To see the optimization done by the compiler we can specify `-gcflags "-m"`

For example when we run the following go code using `go build -gcflags "-m" main.go`

```go
package main

import (
	"fmt"
)

func main() {
	x := 42
	fmt.Println(x)
}
```

We will get result like this:

```sh
# command-line-arguments
.\main.go:9:13: inlining call to fmt.Println
.\main.go:9:13: x escapes to heap
.\main.go:9:13: []interface {} literal does not escape
<autogenerated>:1: .this does not escape
<autogenerated>:1: .this does not escape
```

We can gain more information of the optimization and the escape analysis by specifying the `-m` number for example like `-m=2`

---
Further reading [this](https://segment.com/blog/allocation-efficiency-in-high-performance-go-services/)